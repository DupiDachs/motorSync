import os
import time
import numpy as np
import pandas as pd

def readCSV():
    # Read accelerometer data
    file_path = 'motorSync.csv'
    data = []
    data = pd.DataFrame(data)

    # Check if file exists
    for i in range(5):
        time.sleep(0.1)
        file_name = [f for f in os.listdir('/tmp') if f.endswith('motorSync.csv')]
        if file_name:
            file_path = '/tmp/' + file_name[0]
            break

    # Read and delete the processed CSV file
    if os.path.isfile(file_path):
        data = pd.read_csv(file_path)
        os.remove(file_path)
    else:
    # Error check
        print("/tmp/*motorSync.csv was not generated by ACCELEROMETER_MEASURE.")

    return data

def get_accel(noise):
    # Read accelerometer data
    data = readCSV()

    if not data.empty:
        # Remove gravity and static noise
        data['accel_x'] = (data['accel_x']-noise[0])**2
        data['accel_y'] = (data['accel_y']-noise[1])**2
        data['accel_z'] = (data['accel_z']-noise[2])**2

        # Determine representative index of maximum acceleration
        index_x = np.argmax(data['accel_x'])
        index_y = np.argmax(data['accel_y'])
        index_z = np.argmax(data['accel_z'])
        index = min([index_x, index_y, index_z])

        # Determine magnitude
        magnitude = np.array(np.sqrt(data['accel_x'] + data['accel_y'] + data['accel_z']))

        # Determine sensible timeframe (-2ms before peak ... +10ms after peak)
        before = 0.002
        after = 0.010
        index_start = (np.abs(data['#time'] - (data['#time'][index]-before))).argmin()
        index_end = (np.abs(data['#time'] - (data['#time'][index]+after))).argmin()

        # These checks should not be necessary
        if (index_start < 0):
            index_start = 0
        elif (index_start >= len(magnitude)-1):
            index_start = len(magnitude)-2
            index_end = len(magnitude)
        if (index_end > len(magnitude)-1):
            index_end = len(magnitude)-1
        elif (index_end <= 0):
            index_end = 1
            index_start = 0
        if (index_end < index_start):
            stash = index_end
            index_end = index_start
            index_start = stash
        elif (index_end == index_start):
            index_end = index_start+1

        # Integrate over timeframe
        integral = np.trapz(magnitude[index_start:index_end], data['#time'][index_start:index_end])
        #return (integral, index_start, index_end)
        return integral
    else:
        #return (0, 0, 0)
        return 0
