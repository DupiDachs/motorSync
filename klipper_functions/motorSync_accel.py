import os
import time
import numpy as np
import pandas as pd

def readCSV():
    # Read accelerometer data
    file_path = 'motorSync.csv'
    data = []
    data = pd.DataFrame(data)

    # Check if file exists
    for i in range(5):
        time.sleep(0.1)
        file_name = [f for f in os.listdir('/tmp') if f.endswith('motorSync.csv')]
        if file_name:
            file_path = '/tmp/' + file_name[0]
            break

    # Read and delete the processed CSV file
    if os.path.isfile(file_path):
        data = pd.read_csv(file_path)
        #for i in range(100):
        #    if os.path.isfile(file_path+str(i)):
        #        i = i+1
        #    else:
        #        os.rename(file_path,file_path+str(i))
        #        break
        os.remove(file_path)
    else:
    # Error check
        print("/tmp/*motorSync.csv was not generated by ACCELEROMETER_MEASURE.")

    return data

def get_accel(noise):
    # Read accelerometer data
    data = readCSV()

    if not data.empty:
        # Remove gravity and static noise
        data['accel_x'] = (data['accel_x']-noise[0])**2
        data['accel_y'] = (data['accel_y']-noise[1])**2
        data['accel_z'] = (data['accel_z']-noise[2])**2

        # Determine magnitude
        magnitude = np.array(np.sqrt(data['accel_x'] + data['accel_y'] + data['accel_z']))

        # Determine representative index of maximum acceleration
        max_ind = np.argmax(magnitude)
        index_start = np.argmax(magnitude>magnitude[max_ind]/2)

        # Determine sensible timeframe (time at peak/2 ... +20ms after peak)
        after = 0.020
        index_end = (np.abs(data['#time'] - (data['#time'][max_ind]+after))).argmin()

        # These checks should not be necessary
        if (index_start < 0):
            index_start = 0
        elif (index_start >= len(magnitude)-1):
            index_start = len(magnitude)-2
            index_end = len(magnitude)
        if (index_end > len(magnitude)-1):
            index_end = len(magnitude)-1
        elif (index_end <= 0):
            index_end = 1
            index_start = 0
        if (index_end < index_start):
            stash = index_end
            index_end = index_start
            index_start = stash
        elif (index_end == index_start):
            index_end = index_start+1

        # Integrate over timeframe
        integral = np.trapz(magnitude[index_start:index_end], data['#time'][index_start:index_end])
        #return (integral, index_start, index_end)
        return integral
    else:
        #return (0, 0, 0)
        return 999999
